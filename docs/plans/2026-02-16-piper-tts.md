# Piper TTS Integration Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace macOS-only `say` command with Piper TTS — a local neural network TTS engine that runs on Mac, Linux, and Windows.

**Architecture:** Piper runs as a Tauri sidecar binary. Rust spawns it via `tauri-plugin-shell`, pipes text to stdin, collects raw PCM from stdout. Word timing stays proportional (Piper's C++ binary has no timing output). The `TTSEvent` channel interface is unchanged — frontend is untouched.

**Tech Stack:** Piper TTS (ONNX-based neural TTS), tauri-plugin-shell, raw int16 PCM at 22050 Hz

---

## Context

### Current State
- `src-tauri/src/tts.rs` shells out to macOS `say`, writes AIFF to temp file, reads it back, base64-encodes, sends via `Channel<TTSEvent>`.
- `src/tts/synthesize.ts` collects events into `SynthesisResult { wordTimings, audioBase64, durationMs }`.
- `src/tts/audio-player.ts` decodes base64 audio via Web Audio `decodeAudioData()`.
- `src/tts/use-tts.ts` wraps it in React Query.
- Frontend is engine-agnostic. Only the Rust backend changes.

### Piper CLI Contract
```
echo "Hello world" | ./piper --model voice.onnx --output_raw
```
- Input: text on stdin, close stdin to signal EOF.
- Output: raw int16 PCM on stdout. No headers.
- Sample rate: defined by voice model config (22050 Hz for medium/high quality).
- Channels: mono. Bit depth: 16-bit signed LE.

### Voice Models
- Two files per voice: `name.onnx` (~60 MB) + `name.onnx.json` (config).
- Best default: `en_US-lessac-medium` (22050 Hz, 60 MB).
- Downloaded from `huggingface.co/rhasspy/piper-voices`.

### Sidecar Pattern (Tauri 2)
- Binary goes in `src-tauri/binaries/` with target-triple suffix.
- Declared in `tauri.conf.json` under `bundle.externalBin`.
- Permissions in `src-tauri/capabilities/default.json`.
- Rust: `app.shell().sidecar("binaries/piper").args([...]).spawn()`.
- Requires `tauri-plugin-shell` crate + `.plugin(tauri_plugin_shell::init())`.

### Key Decision: Raw PCM, Not WAV
Piper's `--output_raw` streams int16 PCM with no headers. We collect the bytes, prepend a WAV header in Rust (44 bytes, trivial), then base64-encode. Web Audio's `decodeAudioData()` needs a recognized container format. WAV is the cheapest — fixed 44-byte header, no compression overhead.

### Key Decision: Word Timing Stays Proportional
The C++ Piper binary has no timing output. The new `piper1-gpl` repo has phoneme alignment but only via Python API or patched models with no pre-built binaries. Proportional timing (character offset / total chars * duration) is what we already ship. It works. Revisit when `piper1-gpl` ships compiled binaries with alignment support.

---

## Task 1: Add tauri-plugin-shell dependency

**Files:**
- Modify: `src-tauri/Cargo.toml`
- Modify: `src-tauri/src/lib.rs`
- Modify: `src-tauri/capabilities/default.json`

**Step 1: Add the shell plugin crate to Cargo.toml**

In `src-tauri/Cargo.toml`, add to `[dependencies]`:

```toml
tauri-plugin-shell = "2"
```

**Step 2: Register the plugin in lib.rs**

In `src-tauri/src/lib.rs`, add the plugin to the builder:

```rust
mod tts;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .invoke_handler(tauri::generate_handler![tts::synthesize])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

**Step 3: Add sidecar permissions to capabilities**

In `src-tauri/capabilities/default.json`:

```json
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Default capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    {
      "identifier": "shell:allow-execute",
      "allow": [
        {
          "name": "binaries/piper",
          "sidecar": true,
          "args": true
        }
      ]
    }
  ]
}
```

**Step 4: Verify it compiles**

Run: `cd src-tauri && cargo check`
Expected: compiles with no errors.

**Step 5: Commit**

```bash
git add src-tauri/Cargo.toml src-tauri/src/lib.rs src-tauri/capabilities/default.json
git commit -m "feat(tts): add tauri-plugin-shell for piper sidecar"
```

---

## Task 2: Download and place Piper binary + voice model

**Files:**
- Create: `src-tauri/binaries/piper-aarch64-apple-darwin` (macOS ARM64 binary)
- Create: `src-tauri/binaries/piper-x86_64-apple-darwin` (macOS Intel binary — if needed)
- Create: `src-tauri/resources/piper/` (voice model + espeak-ng-data + libs)
- Modify: `tauri.conf.json` (declare externalBin + resources)
- Create: `scripts/download-piper.sh` (reproducible setup script)

**Step 1: Create the download script**

Create `scripts/download-piper.sh` that:
1. Detects the host platform/arch.
2. Downloads the correct Piper release tarball from `https://github.com/rhasspy/piper/releases/download/2023.11.14-2/`.
3. Extracts the binary to `src-tauri/binaries/piper-{target-triple}`.
4. Extracts `lib/` and `espeak-ng-data/` to `src-tauri/resources/piper/`.
5. Downloads `en_US-lessac-medium.onnx` and `.onnx.json` from Hugging Face to `src-tauri/resources/piper/`.
6. `chmod +x` the binary.

Platform → tarball mapping:
- `aarch64-apple-darwin` → `piper_macos_aarch64.tar.gz`
- `x86_64-apple-darwin` → `piper_macos_x64.tar.gz`
- `x86_64-unknown-linux-gnu` → `piper_linux_x86_64.tar.gz`
- `x86_64-pc-windows-msvc` → `piper_windows_amd64.zip`

Voice model URLs:
- `https://huggingface.co/rhasspy/piper-voices/resolve/v1.0.0/en/en_US/lessac/medium/en_US-lessac-medium.onnx`
- `https://huggingface.co/rhasspy/piper-voices/resolve/v1.0.0/en/en_US/lessac/medium/en_US-lessac-medium.onnx.json`

**Step 2: Run the script**

Run: `bash scripts/download-piper.sh`
Expected: files appear at the correct paths.

**Step 3: Verify the binary runs**

Run: `echo "Hello world" | ./src-tauri/binaries/piper-aarch64-apple-darwin --model src-tauri/resources/piper/en_US-lessac-medium.onnx --output_raw > /dev/null`

Expected: exits 0, no errors. (Audio goes to /dev/null — just testing it runs.)

NOTE: Piper needs `lib/` and `espeak-ng-data/` relative to its binary, OR you set env vars. Test this. If it looks for them relative to CWD or binary path, we may need to set `DYLD_LIBRARY_PATH` or symlink. Determine the exact expectation and document it.

**Step 4: Configure tauri.conf.json**

Add `externalBin` and `resources` to the bundle config:

```json
{
  "bundle": {
    "active": true,
    "targets": "all",
    "externalBin": ["binaries/piper"],
    "resources": {
      "resources/piper/*": "piper/"
    },
    "icon": ["...existing..."]
  }
}
```

The `resources` mapping bundles the voice model, libs, and espeak-ng-data into the app bundle at runtime. Tauri resolves `resource_dir()` to find them.

**Step 5: Add binaries and resources to .gitignore**

These are large binary blobs — don't commit them. Add to `.gitignore`:

```
src-tauri/binaries/piper-*
src-tauri/resources/piper/
```

**Step 6: Commit**

```bash
git add scripts/download-piper.sh tauri.conf.json .gitignore
git commit -m "feat(tts): add piper download script and tauri resource config"
```

---

## Task 3: Rewrite tts.rs to use Piper sidecar

This is the core change. Replace `Command::new("say")` with spawning the Piper sidecar, piping text to stdin, collecting raw PCM from stdout, prepending a WAV header, and emitting the same `TTSEvent` stream.

**Files:**
- Modify: `src-tauri/src/tts.rs`

**Step 1: Write the WAV header builder**

Raw PCM from Piper needs a container for `decodeAudioData()`. WAV is 44 bytes of fixed structure. Pure function, no allocation beyond the output vec.

```rust
/// Prepend a WAV header to raw int16 PCM data.
/// Format: RIFF/WAVE, 16-bit signed LE, mono, at the given sample rate.
fn wav_wrap(pcm: &[u8], sample_rate: u32) -> Vec<u8> {
    let data_len = pcm.len() as u32;
    let file_len = 36 + data_len;
    let byte_rate = sample_rate * 2; // 16-bit mono = 2 bytes/sample
    let mut out = Vec::with_capacity(44 + pcm.len());

    out.extend_from_slice(b"RIFF");
    out.extend_from_slice(&file_len.to_le_bytes());
    out.extend_from_slice(b"WAVE");
    out.extend_from_slice(b"fmt ");
    out.extend_from_slice(&16u32.to_le_bytes());   // fmt chunk size
    out.extend_from_slice(&1u16.to_le_bytes());    // PCM format
    out.extend_from_slice(&1u16.to_le_bytes());    // mono
    out.extend_from_slice(&sample_rate.to_le_bytes());
    out.extend_from_slice(&byte_rate.to_le_bytes());
    out.extend_from_slice(&2u16.to_le_bytes());    // block align
    out.extend_from_slice(&16u16.to_le_bytes());   // bits per sample
    out.extend_from_slice(b"data");
    out.extend_from_slice(&data_len.to_le_bytes());
    out.extend_from_slice(pcm);

    out
}
```

**Step 2: Rewrite the `synthesize` command**

The new flow:
1. Resolve the model path via `app.path().resource_dir()`.
2. Spawn Piper sidecar with `--model <path> --output_raw`.
3. Write text to stdin, drop the child handle to close stdin.
4. Collect all stdout bytes (raw PCM).
5. Compute duration from byte count: `pcm_bytes / 2 / sample_rate * 1000`.
6. Emit `WordBoundary` events (proportional timing — same as before).
7. WAV-wrap the PCM, base64-encode, emit `AudioReady`.

```rust
use base64::Engine;
use serde::Serialize;
use tauri::ipc::Channel;
use tauri::Manager;
use tauri_plugin_shell::ShellExt;
use tauri_plugin_shell::process::CommandEvent;

const SAMPLE_RATE: u32 = 22050;

#[derive(Clone, Serialize)]
#[serde(rename_all = "camelCase", tag = "event", content = "data")]
pub enum TTSEvent {
    #[serde(rename_all = "camelCase")]
    WordBoundary {
        word: String,
        word_index: usize,
        char_offset: usize,
        start_ms: f64,
        end_ms: f64,
    },
    #[serde(rename_all = "camelCase")]
    AudioReady {
        audio_base64: String,
        duration_ms: f64,
    },
    Error {
        message: String,
    },
}

struct WordSpan {
    word: String,
    index: usize,
    char_offset: usize,
    char_end: usize,
}

#[tauri::command]
pub async fn synthesize(
    app: tauri::AppHandle,
    text: String,
    on_event: Channel<TTSEvent>,
) -> Result<(), String> {
    let words = extract_words(&text);
    let total_chars = text.len().max(1);

    // Resolve voice model path from bundled resources.
    let resource_dir = app.path().resource_dir()
        .map_err(|e| format!("Failed to resolve resource dir: {e}"))?;
    let model_path = resource_dir
        .join("piper")
        .join("en_US-lessac-medium.onnx");

    let model_str = model_path.to_string_lossy().to_string();

    // Spawn Piper sidecar: text on stdin, raw PCM on stdout.
    let (mut rx, mut child) = app.shell()
        .sidecar("binaries/piper")
        .map_err(|e| format!("Failed to create piper command: {e}"))?
        .args(["--model", &model_str, "--output_raw"])
        .spawn()
        .map_err(|e| format!("Failed to spawn piper: {e}"))?;

    // Pipe text to stdin, then close it so Piper processes and exits.
    child
        .write(format!("{text}\n").as_bytes())
        .map_err(|e| format!("Failed to write to piper stdin: {e}"))?;
    // NOTE: Tauri's CommandChild doesn't expose drop-to-close-stdin directly.
    // We send a newline and rely on Piper processing one line then outputting audio.
    // If Piper hangs, we may need to kill the child after a timeout.

    // Collect raw PCM bytes from stdout.
    let mut pcm_bytes: Vec<u8> = Vec::new();
    let mut stderr_buf = String::new();

    while let Some(event) = rx.recv().await {
        match event {
            CommandEvent::Stdout(chunk) => pcm_bytes.extend_from_slice(&chunk),
            CommandEvent::Stderr(chunk) => {
                stderr_buf.push_str(&String::from_utf8_lossy(&chunk));
            }
            CommandEvent::Terminated(status) => {
                if status.code != Some(0) {
                    let msg = format!("Piper exited with code {:?}: {stderr_buf}", status.code);
                    let _ = on_event.send(TTSEvent::Error { message: msg.clone() });
                    return Err(msg);
                }
                break;
            }
            _ => {}
        }
    }

    if pcm_bytes.is_empty() {
        let msg = format!("Piper produced no audio. stderr: {stderr_buf}");
        let _ = on_event.send(TTSEvent::Error { message: msg.clone() });
        return Err(msg);
    }

    // Duration from raw PCM: samples = bytes / 2 (16-bit), duration = samples / sample_rate.
    let duration_ms = (pcm_bytes.len() as f64 / 2.0 / SAMPLE_RATE as f64) * 1000.0;

    // Emit word boundaries (proportional timing).
    for word in &words {
        let start_ratio = word.char_offset as f64 / total_chars as f64;
        let end_ratio = word.char_end as f64 / total_chars as f64;
        let _ = on_event.send(TTSEvent::WordBoundary {
            word: word.word.clone(),
            word_index: word.index,
            char_offset: word.char_offset,
            start_ms: start_ratio * duration_ms,
            end_ms: end_ratio * duration_ms,
        });
    }

    // Wrap raw PCM in WAV container for Web Audio decodeAudioData().
    let wav = wav_wrap(&pcm_bytes, SAMPLE_RATE);
    let audio_base64 = base64::engine::general_purpose::STANDARD.encode(&wav);
    let _ = on_event.send(TTSEvent::AudioReady {
        audio_base64,
        duration_ms,
    });

    Ok(())
}

// extract_words stays exactly the same — omitted for brevity.
```

**Critical change:** The `synthesize` command now takes `app: tauri::AppHandle` as a parameter. Tauri 2 injects this automatically for `#[tauri::command]` functions.

**Step 3: Update the comment on audio-player.ts**

In `src/tts/audio-player.ts` line 25, update the doc comment from "AIFF from macOS say" to reflect WAV from Piper:

```typescript
/** Decode base64-encoded audio (WAV from Piper TTS) into an AudioBuffer. */
```

**Step 4: Verify it compiles**

Run: `cd src-tauri && cargo check`
Expected: compiles. (Can't run yet — need the binary in place from Task 2.)

**Step 5: Commit**

```bash
git add src-tauri/src/tts.rs src/tts/audio-player.ts
git commit -m "feat(tts): rewrite backend to use piper sidecar over stdin/stdout"
```

---

## Task 4: Handle Piper's library path requirements

Piper needs `lib/` (libonnxruntime, libpiper_phonemize, libespeak-ng) and `espeak-ng-data/` accessible at runtime. The official release tarball puts them next to the binary. But Tauri sidecars live in `externalBin` and resources live in `resources/` — different paths at runtime.

**Files:**
- Modify: `src-tauri/src/tts.rs` (set env vars before spawn)

**Step 1: Determine Piper's library search behavior**

Test manually:
```bash
# From the project root
DYLD_LIBRARY_PATH=src-tauri/resources/piper/lib \
PIPER_PHONEMIZE_ESPEAK_DATA=src-tauri/resources/piper/espeak-ng-data \
echo "Hello" | ./src-tauri/binaries/piper-aarch64-apple-darwin \
  --model src-tauri/resources/piper/en_US-lessac-medium.onnx \
  --output_raw > /dev/null
```

On Linux, use `LD_LIBRARY_PATH` instead of `DYLD_LIBRARY_PATH`.
On Windows, the DLLs must be in the same directory as the exe, or on `PATH`.

**Step 2: Set environment variables in the spawn call**

Update the sidecar spawn in `tts.rs` to set the library path:

```rust
let lib_dir = resource_dir.join("piper").join("lib");
let espeak_data_dir = resource_dir.join("piper").join("espeak-ng-data");

// Platform-specific library path env var.
let lib_path_var = if cfg!(target_os = "macos") {
    "DYLD_LIBRARY_PATH"
} else if cfg!(target_os = "linux") {
    "LD_LIBRARY_PATH"
} else {
    "PATH"
};

let (mut rx, mut child) = app.shell()
    .sidecar("binaries/piper")
    .map_err(|e| format!("Failed to create piper command: {e}"))?
    .args(["--model", &model_str, "--output_raw"])
    .env(lib_path_var, lib_dir.to_string_lossy().as_ref())
    .env("PIPER_PHONEMIZE_ESPEAK_DATA", espeak_data_dir.to_string_lossy().as_ref())
    .spawn()
    .map_err(|e| format!("Failed to spawn piper: {e}"))?;
```

NOTE: Verify that `tauri_plugin_shell::CommandBuilder` has an `.env()` method. If not, we may need to use `std::process::Command` directly instead of the sidecar API, or set the env vars on the process globally before spawn. Check the plugin API.

If the shell plugin doesn't support `.env()`, the fallback is:
- On macOS/Linux: use `std::env::set_var` before spawn (not ideal for concurrency).
- Or: use `std::process::Command` directly (bypasses sidecar, but still works — we just lose the Tauri sidecar path resolution and need to resolve the binary path ourselves).

**Step 3: Test end-to-end**

Run: `cd src-tauri && cargo tauri dev`
Expected: the app launches, TTS produces audio from Piper.

**Step 4: Commit**

```bash
git add src-tauri/src/tts.rs
git commit -m "feat(tts): configure piper library paths for cross-platform runtime"
```

---

## Task 5: Handle stdin close for Piper

**Problem:** Piper reads stdin until EOF, then synthesizes. Tauri's `CommandChild` has a `write()` method but no explicit `close_stdin()`. Simply dropping the `child` value kills the process.

**Files:**
- Modify: `src-tauri/src/tts.rs`

**Step 1: Investigate Tauri's CommandChild API**

Check if `CommandChild` has a way to close stdin without killing the process. The Tauri docs show `child.write()` but nothing about closing stdin.

Options if stdin can't be closed:
1. **Use `--json-input` mode**: Piper processes one JSON object per line and can produce output per-line. But `--output_raw` streams continuously — unclear if it flushes per-line.
2. **Use `std::process::Command` directly**: Full control over stdin/stdout pipes. Lose sidecar path magic but gain correct behavior.
3. **Write to a temp file, pass as argument**: Avoid stdin entirely. Piper accepts `--output_file` but not `--input_file`. Text goes on stdin regardless.

**Most likely solution:** Use `std::process::Command` directly instead of the sidecar API. Resolve the binary path manually using Tauri's resource dir. This gives us `stdin.take()` → `drop(stdin)` → EOF → Piper processes → stdout collects.

```rust
use std::process::{Command, Stdio};
use std::io::Write;

let binary_path = /* resolve sidecar path based on platform */;

let mut child = Command::new(&binary_path)
    .args(["--model", &model_str, "--output_raw"])
    .env(lib_path_var, &lib_dir_str)
    .env("PIPER_PHONEMIZE_ESPEAK_DATA", &espeak_data_str)
    .stdin(Stdio::piped())
    .stdout(Stdio::piped())
    .stderr(Stdio::piped())
    .spawn()
    .map_err(|e| format!("Failed to spawn piper: {e}"))?;

// Write text and close stdin.
{
    let stdin = child.stdin.as_mut()
        .ok_or("Failed to open piper stdin")?;
    writeln!(stdin, "{text}")
        .map_err(|e| format!("Failed to write to piper: {e}"))?;
}
// stdin is dropped here — Piper receives EOF and begins synthesis.

let output = child.wait_with_output()
    .map_err(|e| format!("Piper failed: {e}"))?;

if !output.status.success() {
    let stderr = String::from_utf8_lossy(&output.stderr);
    let msg = format!("Piper exited with {}: {stderr}", output.status);
    let _ = on_event.send(TTSEvent::Error { message: msg.clone() });
    return Err(msg);
}

let pcm_bytes = output.stdout;
```

This is simpler than the sidecar async event loop. `wait_with_output()` blocks the async task but that's fine — synthesis is inherently sequential per call, and we're already on an async Tauri command thread.

**Step 2: Resolve sidecar binary path**

Tauri places sidecar binaries next to the app binary at build time. At runtime:

```rust
use tauri::Manager;

fn piper_binary_path(app: &tauri::AppHandle) -> Result<std::path::PathBuf, String> {
    let exe_dir = app.path().resource_dir()
        .map_err(|e| format!("Can't resolve resource dir: {e}"))?;

    let binary_name = if cfg!(target_os = "windows") {
        "piper.exe"
    } else {
        "piper"
    };

    // Tauri places externalBin binaries in the resource directory.
    let path = exe_dir.join(binary_name);
    if path.exists() {
        return Ok(path);
    }

    // Dev mode: binaries are in src-tauri/binaries/ with target triple suffix.
    // Try the conventional sidecar location.
    Err(format!("Piper binary not found at {}", path.display()))
}
```

NOTE: The exact runtime path depends on the platform and whether we're in dev vs bundled mode. This needs testing. In dev mode, Tauri resolves sidecars from `src-tauri/binaries/piper-{triple}`. In production, they're in the app bundle's resource directory. We may need to use `app.shell().sidecar("binaries/piper")` just for path resolution, then use `std::process::Command` for execution. Or just use the sidecar API and accept that we can't close stdin — test whether Piper actually needs EOF or if a newline suffices.

**Step 3: Test that Piper actually produces output after newline (without EOF)**

Run manually:
```bash
printf "Hello world\n" | timeout 10 ./piper --model voice.onnx --output_raw > /tmp/test.pcm
```

If Piper outputs after the newline (before stdin EOF), then the Tauri sidecar API works fine and Task 5 is unnecessary. The `CommandEvent::Terminated` event fires when Piper exits.

**Step 4: Commit (if changes were needed)**

```bash
git add src-tauri/src/tts.rs
git commit -m "fix(tts): ensure stdin close for piper EOF signal"
```

---

## Task 6: End-to-end testing and cleanup

**Files:**
- All TTS files (verify, no modify expected)

**Step 1: Run the app in dev mode**

Run: `cd src-tauri && cargo tauri dev`

**Step 2: Trigger TTS playback**

Navigate to a lesson, start playback. Verify:
- [ ] Audio plays (Piper voice, not system `say`)
- [ ] Word highlighting tracks (approximately — proportional timing)
- [ ] Visualization triggers fire at correct-ish times
- [ ] Pause/resume works
- [ ] Different lesson steps re-synthesize correctly
- [ ] Same text cache-hits (React Query — no re-synthesis)

**Step 3: Test error cases**

- Delete the model file temporarily → verify graceful error
- Pass empty string → verify `enabled: text.length > 0` prevents call

**Step 4: Remove dead code**

If the old AIFF-specific duration calculation in tts.rs is gone (it should be — Task 3 replaced it), verify no references to AIFF remain in the codebase:

Run: `grep -r "aiff\|AIFF\|say" src-tauri/src/ src/tts/`
Expected: no matches (except possibly this plan file).

**Step 5: Final commit**

```bash
git add -A
git commit -m "chore(tts): cleanup after piper migration"
```

---

## Task Order & Dependencies

```
Task 1 (shell plugin) → Task 2 (download binary) → Task 3 (rewrite tts.rs) → Task 4 (lib paths) → Task 5 (stdin close) → Task 6 (e2e test)
```

Tasks 1 and 2 are independent and can run in parallel. Tasks 3-5 are sequential — each builds on the previous. Task 6 validates everything.

---

## Bundle Size Impact

| Component | Size |
|---|---|
| Piper binary | ~19 MB (macOS) |
| Piper libs (onnxruntime, espeak-ng, piper_phonemize) | ~15 MB |
| espeak-ng-data | ~3 MB |
| Voice model (lessac-medium) | ~60 MB |
| **Total added** | **~97 MB** |

Mitigation: download voice models on first run instead of bundling. Deferred — ship bundled first, optimize later.

---

## What Doesn't Change (Frontend)

- `src/tts/synthesize.ts` — untouched (same `TTSEvent` discriminated union)
- `src/tts/use-tts.ts` — untouched (same React Query wrapper)
- `src/tts/audio-player.ts` — one comment updated (AIFF → WAV)
- `src/presentation/*` — untouched (timeline, scheduler, store, components)
